<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>D3 Team Timeline</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
  <script src="data.js"></script>
  <style>
    body { 
      font-family: system-ui, Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      overflow-y: auto;
    }
    
    #axisContainer {
      position: sticky;
      bottom: 0;
      background: white;
      z-index: 99;
      padding: 0 20px 0 20px;
      border-top: 1px solid #eee;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.05);
    }
    
    #chartContainer {
      padding: 0 20px 0px 20px;
    }
    
    .axis text { font-size: 12px; }
    .row-label { font-size: 12px; dominant-baseline: middle; }
    .seg-label { font-size: 11px; dominant-baseline: middle; pointer-events: none; }
    .grid line { stroke: #e6e6e6; }
    .grid path { display: none; }
    
    #tooltip {
      position: fixed;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s;
      z-index: 1000;
    }
    
    #yearTooltip {
      position: fixed;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 3px;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
      opacity: 0;
      z-index: 999;
    }
    
    .year-highlight-line {
      stroke: rgba(255, 0, 0, 0.5);
      stroke-width: 2;
      pointer-events: none;
    }
    
    .dg.ac {
      z-index: 1000 !important;
    }
  </style>
</head>
<body>
  <div id="tooltip"></div>
  <div id="yearTooltip"></div>
  <div id="teamCount" style="position: fixed; bottom: 10px; right: 10px; font-size: 14px; font-weight: bold; color: #666; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 4px; z-index: 1001; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
  
  <div id="chartContainer">
    <svg id="chart"></svg>
  </div>
  
  <div id="axisContainer">
    <svg id="axisChart"></svg>
  </div>

  <script>
    const tooltip = d3.select("#tooltip");
    
    // Calculate all years when team count changed
    function getSignificantYears() {
      const allYears = new Set();
      globalData.teams.forEach(team => {
        team.segments.forEach(seg => {
          allYears.add(seg.start);
          if (seg.end) allYears.add(seg.end);
        });
      });
      return Array.from(allYears).sort((a, b) => a - b);
    }
    
    const significantYears = getSignificantYears();
    const currentYear = new Date().getFullYear();
    
    // Settings object for dat.gui
    const settings = {
      showDefunct: false,
      showChampions: false,
      showMarkers: true,
      showWrappedLabels: false,
      leagueFilter: 'all',
      sortBy: 'founded',
      searchTeam: '',
      selectedYear: currentYear,
      resetFilters: function() {
        this.showDefunct = false;
        this.showChampions = false;
        this.showMarkers = true;
        this.showWrappedLabels = false;
        this.leagueFilter = 'all';
        this.sortBy = 'founded';
        this.searchTeam = '';
        this.selectedYear = currentYear;
        gui.updateDisplay();
        renderChart();
      },
      resetYear: function() {
        this.selectedYear = currentYear;
        gui.updateDisplay();
        renderChart();
      }
    };
    
    // Create dat.gui
    const gui = new dat.GUI({ width: 300, autoPlace: false });
    
    // Position it at bottom left
    gui.domElement.style.position = 'fixed';
    gui.domElement.style.left = '10px';
    gui.domElement.style.bottom = '25px';
    gui.domElement.style.zIndex = '1000';
    document.body.appendChild(gui.domElement);
    
    // Filters folder
    const filtersFolder = gui.addFolder('Filters');
    filtersFolder.add(settings, 'showDefunct').name('Show Defunct Teams').onChange(renderChart);
    filtersFolder.add(settings, 'showChampions').name('Only Champions').onChange(renderChart);
    filtersFolder.add(settings, 'showMarkers').name('Show Championship Markers').onChange(renderChart);
    filtersFolder.add(settings, 'showWrappedLabels').name('Show Wrapped Labels').onChange(renderChart);
    filtersFolder.add(settings, 'leagueFilter', ['all', 'NBA', 'ABA', 'NBL']).name('League').onChange(renderChart);
    filtersFolder.add(settings, 'sortBy', ['name', 'championships', 'founded', 'conference']).name('Sort By').onChange(renderChart);
    filtersFolder.add(settings, 'searchTeam').name('Search Team').onChange(renderChart);
    
    // Time Travel folder
    const timeFolder = gui.addFolder('Time Travel');
    timeFolder.add(settings, 'selectedYear', d3.min(significantYears), currentYear, 1).name('Year').onChange(renderChart);
    timeFolder.add(settings, 'resetYear').name('Reset Year');
    
    // Actions folder
    const actionsFolder = gui.addFolder('Actions');
    actionsFolder.add(settings, 'resetFilters').name('Reset All Filters');

    function renderChart() {
      // Clear existing chart and axis
      d3.select("#chart").selectAll("*").remove();
      d3.select("#axisChart").selectAll("*").remove();

      // Get filter values from settings object
      const showDefunct = settings.showDefunct;
      const showChampions = settings.showChampions;
      const showMarkers = settings.showMarkers;
      const showWrappedLabels = settings.showWrappedLabels;
      const leagueFilter = settings.leagueFilter;
      const sortBy = settings.sortBy;
      const searchTerm = settings.searchTeam.toLowerCase();
      const selectedYear = Math.round(settings.selectedYear);

      // Filter data based on all criteria
      let data = globalData.teams;
      
      // Filter by year - only show teams that existed in NBA in the selected year
      if (selectedYear < currentYear) {
        data = data.filter(team => {
          return team.segments.some(seg => {
            return seg.start <= selectedYear && 
                   (!seg.end || seg.end >= selectedYear) &&
                   seg.league === "NBA";
          });
        });
      }
      
      // Filter defunct teams
      if (!showDefunct) {
        data = data.filter(team => {
          return team.segments.some(s => !s.end);
        });
      }
      
      // Filter only teams with championships
      if (showChampions) {
        data = data.filter(team => team.markers && team.markers.length > 0);
      }
      
      // Filter by league
      if (leagueFilter !== "all") {
        data = data.filter(team => {
          return team.segments.some(s => s.league === leagueFilter);
        });
      }
      
      // Filter by search term
      if (searchTerm) {
        data = data.filter(team => {
          return team.lastName.toLowerCase().includes(searchTerm) ||
                 team.segments.some(s => s.label.toLowerCase().includes(searchTerm));
        });
      }
      
      // Sort data
      if (sortBy === "championships") {
        data = data.sort((a, b) => {
          const aCount = (a.markers || []).length;
          const bCount = (b.markers || []).length;
          return bCount - aCount; // Descending
        });
      } else if (sortBy === "founded") {
        data = data.sort((a, b) => {
          const aStart = d3.min(a.segments, s => s.start);
          const bStart = d3.min(b.segments, s => s.start);
          return aStart - bStart; // Ascending
        });
      } else if (sortBy === "conference") {
        // Define conference and division order
        const conferenceOrder = { "Eastern": 0, "Western": 1 };
        const divisionOrder = {
          "Atlantic": 0, "Central": 1, "Southeast": 2,  // Eastern divisions
          "Northwest": 3, "Pacific": 4, "Southwest": 5   // Western divisions
        };
        
        data = data.sort((a, b) => {
          // Teams without conference go to the end
          if (!a.conference && !b.conference) return a.lastName.localeCompare(b.lastName);
          if (!a.conference) return 1;
          if (!b.conference) return -1;
          
          // Sort by conference first
          const confCompare = conferenceOrder[a.conference] - conferenceOrder[b.conference];
          if (confCompare !== 0) return confCompare;
          
          // Then by division
          const divCompare = divisionOrder[a.division] - divisionOrder[b.division];
          if (divCompare !== 0) return divCompare;
          
          // Finally by name within division
          return a.lastName.localeCompare(b.lastName);
        });
      } else { // name
        data = data.sort((a, b) => a.lastName.localeCompare(b.lastName));
      }
      
      // Update team count
      d3.select("#teamCount").text(`Showing ${data.length} team${data.length !== 1 ? 's' : ''}`);

      // ---- 2) Layout ----
      const svg = d3.select("#chart");
      const width = window.innerWidth - 40; // full width minus padding
      // Add extra right margin when sorted by conference for indicators
      const margin = { top: 40, right: sortBy === "conference" ? 55 : 30, bottom: 0, left: 30 };
      const rowH = 26;
      const height = margin.top + margin.bottom + data.length * rowH;

      svg.attr("width", width).attr("height", height);

      const innerW = width - margin.left - margin.right;
      const innerH = height - margin.top - margin.bottom;

      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

      // ---- 3) Scales ----
      const minYear = d3.min(data, d => d3.min(d.segments, s => s.start));
      const maxYear = selectedYear;

      // Piecewise scale: compress pre-1946, expand 1946+
      const breakYear = 1946;
      const preBreakRatio = 0.05; // Pre-1946 takes only 5% of width
      
      const x = d3.scaleLinear()
        .domain([minYear, breakYear, maxYear])
        .range([0, innerW * preBreakRatio, innerW]);

      const y = d3.scaleBand()
        .domain(data.map(d => d.lastName))
        .range([0, innerH])
        .paddingInner(0.25);

      // ---- 4) Grid ----
      const gridTicks = x.ticks(20).filter(year => year >= breakYear);
      
      const grid = d3.axisBottom(x)
        .tickValues(gridTicks)
        .tickSize(-innerH)
        .tickFormat("");

      g.append("g")
        .attr("class", "grid")
        .attr("transform", `translate(0,${innerH})`)
        .call(grid);

      // ---- 4b) Sticky X-Axis (in separate SVG) ----
      const axisSvg = d3.select("#axisChart");
      axisSvg.attr("width", width).attr("height", 35);
      
      const axisG = axisSvg.append("g")
        .attr("transform", `translate(${margin.left},10)`);
      
      const xAxis = d3.axisBottom(x)
        .tickValues(gridTicks)
        .tickFormat(d3.format("d"));
      
      axisG.append("g")
        .attr("class", "axis")
        .call(xAxis);

      // ---- 6) Segments (colored bars) ----
      const row = g.append("g")
        .selectAll("g.row")
        .data(data)
        .join("g")
        .attr("class", "row")
        .attr("transform", d => `translate(0,${y(d.lastName)})`);

    
      const rects = row.selectAll("rect")
        .data(d => d.segments.map(s => ({...s, team: d.lastName})))
        .join("rect")
        .attr("x", s => x(s.start))
        .attr("y", 0)
        .attr("width", s => {
          const endYear = Math.min(s.end || selectedYear, selectedYear);
          return Math.max(1, x(endYear) - x(s.start));
        })
        .attr("height", y.bandwidth())
        .attr("fill", s => s.backgroundColor || "#CCCCCC")
        .on("mouseover", function(event, s) {
          tooltip
            .style("opacity", 1)
            .html(`${s.label}<br/>${s.start}â€“${s.end || 'present'}`)
            .style("left", (event.clientX + 10) + "px")
            .style("top", (event.clientY - 10) + "px");
        })
        .on("mousemove", function(event) {
          tooltip
            .style("left", (event.clientX + 10) + "px")
            .style("top", (event.clientY - 10) + "px");
        })
        .on("mouseout", function() {
          tooltip.style("opacity", 0);
        });

      // ---- 6b) Lines between segments ----
      row.selectAll("line.segment-divider")
        .data(d => d.segments.slice(0, -1).map((s, i) => ({
          x: Math.min(s.end || selectedYear, selectedYear),
          team: d.lastName
        })).filter(s => s.x <= selectedYear))
        .join("line")
        .attr("class", "segment-divider")
        .attr("x1", s => x(s.x))
        .attr("x2", s => x(s.x))
        .attr("y1", 0)
        .attr("y2", y.bandwidth())
        .attr("stroke", "#333333")
        .attr("stroke-width", 3);

      // ---- 7) Segment labels (wrap text if needed) ----
      row.selectAll("text.seg-label")
        .data(d => d.segments.map((s, i) => ({...s, team: d.lastName, segmentIndex: i})))
        .join("text")
        .attr("class", "seg-label")
        .attr("y", y.bandwidth() / 2)
        .attr("fill", s => s.textColor || "#000000")
        .each(function(s) {
          const textElement = d3.select(this);
          textElement.selectAll("*").remove(); // Clear any existing content
          
          const words = s.label.split(' ');
          const endYear = Math.min(s.end || selectedYear, selectedYear);
          const segW = x(endYear) - x(s.start);
          const centerX = (x(s.start) + x(endYear)) / 2;
          const rightX = x(endYear) - 6;
          const leftX = x(s.start) - 6;
          const lineHeight = 12;
          
          // Check if it's the first segment and text won't fit
          const isFirstSegment = s.segmentIndex === 0;
          const singleLineText = s.label;
          const tempTspan = textElement.append("tspan").text(singleLineText);
          const textWidth = tempTspan.node().getComputedTextLength();
          tempTspan.remove();
          
          if (isFirstSegment && textWidth + 12 > segW) {
            // Place label to the left of the segment
            textElement.append("tspan")
              .attr("x", leftX)
              .attr("dy", 0)
              .text(s.label);
            textElement.attr("text-anchor", "end");
            textElement.attr("fill", "#000000"); // Black text for external labels
            return; // Exit early, don't wrap
          }
          
          let line = [];
          let lineNumber = 0;
          
          // Start with right-aligned position
          let tspan = textElement.append("tspan")
            .attr("x", rightX)
            .attr("dy", 0);
          
          words.forEach((word, i) => {
            line.push(word);
            tspan.text(line.join(' '));
            
            if (tspan.node().getComputedTextLength() + 12 > segW && line.length > 1) {
              line.pop();
              tspan.text(line.join(' '));
              line = [word];
              tspan = textElement.append("tspan")
                .attr("x", rightX)
                .attr("dy", lineHeight)
                .text(word);
              lineNumber++;
            }
          });
        
        // If wrapped (multiple lines), center align; otherwise right align
        if (lineNumber > 0) {
          if (showWrappedLabels) {
            textElement.attr("text-anchor", "middle");
            textElement.selectAll("tspan").attr("x", centerX);
          } else {
            // Hide wrapped labels if toggle is off
            textElement.remove();
            return;
          }
        } else {
          textElement.attr("text-anchor", "end");
        }
        
        // Adjust vertical position to center multi-line text
        const totalHeight = (lineNumber + 1) * lineHeight;
        textElement.attr("transform", `translate(0, ${-totalHeight / 2 + lineHeight / 2})`);
      });

      // ---- 8) Markers (championship dots) ----
      if (showMarkers) {
        row.selectAll("circle")
          .data(d => (d.markers || []).filter(m => m.year <= selectedYear).map(m => ({...m, team: d.lastName})))
          .join("circle")
          .attr("cx", m => x(m.year))
          .attr("cy", y.bandwidth() / 1.5)
          .attr("r", 3)
          .attr("fill", "white")
          .attr("stroke", "#333")
          .on("mouseover", function(event, m) {
            tooltip
              .style("opacity", 1)
              .html(`${m.label ?? 'Marker'}<br/>${m.year}`)
              .style("left", (event.clientX + 10) + "px")
              .style("top", (event.clientY - 10) + "px");
          })
          .on("mousemove", function(event) {
            tooltip
              .style("left", (event.clientX + 10) + "px")
              .style("top", (event.clientY - 10) + "px");
          })
          .on("mouseout", function() {
            tooltip.style("opacity", 0);
          });
      }

    // ---- 9) Year highlight line (render last so it's on top) ----
    g.append("line")
      .attr("class", "year-highlight-line")
      .attr("y1", 0)
      .attr("y2", innerH)
      .style("opacity", 0);

    // ---- 10) Track mouse across entire SVG ----
    const yearTooltip = d3.select("#yearTooltip");
    const yearHighlightLine = g.select(".year-highlight-line");
    
    svg.on("mousemove", function(event) {
      const [mouseX, mouseY] = d3.pointer(event);
      // Adjust for margins
      const adjustedX = mouseX - margin.left;
      const adjustedY = mouseY - margin.top;
      
      // Check if we're in the chart area
      if (adjustedX >= 0 && adjustedX <= innerW && adjustedY >= 0 && adjustedY <= innerH) {
        const year = Math.round(x.invert(adjustedX));
        
        yearHighlightLine
          .attr("x1", adjustedX)
          .attr("x2", adjustedX)
          .style("opacity", 1);
        
        yearTooltip
          .style("opacity", 1)
          .text(year)
          .style("left", (event.clientX) + "px")
          .style("top", (event.clientY - 40) + "px");
      } else {
        yearHighlightLine.style("opacity", 0);
        yearTooltip.style("opacity", 0);
      }
    })
    .on("mouseleave", function() {
      yearHighlightLine.style("opacity", 0);
      yearTooltip.style("opacity", 0);
    });

    // ---- : a vertical reference line  ----
    for (const {year, label, textAnchor} of globalData.refYears.filter(ref => ref.year <= selectedYear)) {
        g.append("line")
        .attr("x1", x(year))
        .attr("x2", x(year))
        .attr("y1", 0)
        .attr("y2", innerH)
        .attr("stroke", "#666")
        .attr("stroke-width", 1);

        g.append("text")
        .attr("x", x(year))
        .attr("y", -10)
        .attr("text-anchor", textAnchor)
        .attr("font-size", 12)
        .text(label);
    }

    // ---- 11) Conference/Division indicators (when sorted by conference) ----
    if (sortBy === "conference") {
      const conferenceColors = {
        "Eastern": "#0066cc",
        "Western": "#cc3333"
      };
      
      const divisionColors = {
        "Atlantic": "#1e90ff",     // Dodger Blue
        "Central": "#4169e1",      // Royal Blue
        "Southeast": "#6495ed",    // Cornflower Blue
        "Northwest": "#ff6b6b",    // Light Red
        "Pacific": "#ff4757",      // Red
        "Southwest": "#ee5a6f"     // Dark Pink
      };
      
      const barWidth = 8;
      const gap = 5;
      
      // Group teams by conference and division
      const conferenceGroups = d3.group(data, d => d.conference);
      const divisionGroups = d3.group(data, d => `${d.conference}-${d.division}`);
      
      // Draw division bars (left)
      divisionGroups.forEach((teams, key) => {
        const firstTeam = teams[0];
        if (firstTeam.conference && firstTeam.division) {
          const lastTeam = teams[teams.length - 1];
          const yStart = y(firstTeam.lastName);
          const yEnd = y(lastTeam.lastName) + y.bandwidth();
          
          g.append("rect")
            .attr("x", innerW + gap)
            .attr("y", yStart)
            .attr("width", barWidth)
            .attr("height", yEnd - yStart)
            .attr("fill", divisionColors[firstTeam.division])
            .attr("rx", 2)
            .style("cursor", "pointer")
            .on("mouseover", function(event) {
              const tooltipNode = tooltip.node();
              tooltip
                .style("opacity", 1)
                .html(`<strong>${firstTeam.division}</strong> Division<br/>${firstTeam.conference} Conference`);
              const tooltipWidth = tooltipNode.offsetWidth;
              tooltip
                .style("left", (event.clientX - tooltipWidth - 10) + "px")
                .style("top", (event.clientY - 10) + "px");
            })
            .on("mousemove", function(event) {
              const tooltipNode = tooltip.node();
              const tooltipWidth = tooltipNode.offsetWidth;
              tooltip
                .style("left", (event.clientX - tooltipWidth - 10) + "px")
                .style("top", (event.clientY - 10) + "px");
            })
            .on("mouseout", function() {
              tooltip.style("opacity", 0);
            });
        }
      });
      
      // Draw conference bars (right)
      conferenceGroups.forEach((teams, conference) => {
        if (conference && conference !== "undefined") {
          const firstTeam = teams[0];
          const lastTeam = teams[teams.length - 1];
          const yStart = y(firstTeam.lastName);
          const yEnd = y(lastTeam.lastName) + y.bandwidth();
          
          g.append("rect")
            .attr("x", innerW + gap + barWidth + gap)
            .attr("y", yStart)
            .attr("width", barWidth)
            .attr("height", yEnd - yStart)
            .attr("fill", conferenceColors[conference])
            .attr("rx", 2)
            .style("cursor", "pointer")
            .on("mouseover", function(event) {
              const tooltipNode = tooltip.node();
              tooltip
                .style("opacity", 1)
                .html(`<strong>${conference}</strong> Conference`);
              const tooltipWidth = tooltipNode.offsetWidth;
              tooltip
                .style("left", (event.clientX - tooltipWidth - 10) + "px")
                .style("top", (event.clientY - 10) + "px");
            })
            .on("mousemove", function(event) {
              const tooltipNode = tooltip.node();
              const tooltipWidth = tooltipNode.offsetWidth;
              tooltip
                .style("left", (event.clientX - tooltipWidth - 10) + "px")
                .style("top", (event.clientY - 10) + "px");
            })
            .on("mouseout", function() {
              tooltip.style("opacity", 0);
            });
        }
      });
    }
  }

  // Initial render
  renderChart();
  </script>
</body>
</html>
